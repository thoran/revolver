#!/usr/bin/env ruby
# revolver

# 20250929
# 0.4.1

# Description: Switch DNS resolvers at random.

# Changes since 0.3:
# -/0: Allow selection of a specific resolver for listing or switching.
# 1. + find_resolver(): Return the resolver requested by name or raise.
# 2. ~ list(): If resolver_name is present then list that resolver only.
# 3. ~ switch(): If resolver_name is present, then find that resolver, else choose a random resolver.
# 4. ~ main(): Introduce ARGV[1] to list and switch calls; and change the usage string accordingly.
# 5. ~ verify_dns_change(): Reduce sleep from 5 to 3 as that seems to be just enough time.
# 0/1: Handle the edge case where the same DNS resolver is given as is current.
# 6. + verify_proposed_change(): Check whether an effective no-op is happening.
# 7. ~ switch(): Verify the proposed change as soon as we have a candidate.

require 'FileUtils/which'
require 'MacOS/HardwarePort'
require 'MacOS/IfConfig'
require 'MacOS/VPN'

class Revolver
  RESOLVERS = [
    {
      name: 'AdGuard',
      servers: ['94.140.14.14', '94.140.15.15'],
      source: 'https://github.com/curl/curl/wiki/DNS-over-HTTPS'
    },
    {
      name: 'CleanBrowsing',
      servers: ['185.228.168.9', '185.228.169.9'],
      source: 'https://github.com/curl/curl/wiki/DNS-over-HTTPS'
    },
    {
      name: 'Cloudflare',
      servers: ['1.1.1.1', '1.0.0.1'],
      source: 'https://github.com/curl/curl/wiki/DNS-over-HTTPS'
    },
    {
      name: 'Control D',
      servers: ['76.76.2.0', '76.76.10.0'],
      source: 'https://github.com/curl/curl/wiki/DNS-over-HTTPS'
    },
    {
      name: 'Google',
      servers: ['8.8.8.8', '8.8.4.4'],
      source: 'https://github.com/curl/curl/wiki/DNS-over-HTTPS'
    },
    {
      name: 'Mullvad',
      servers: ['194.242.2.2', '194.242.2.3'],
      source: 'https://raw.githubusercontent.com/DNSCrypt/dnscrypt-resolvers/master/v3/public-resolvers.md'
    },
    {
      name: 'NextDNS',
      servers: ['45.90.28.0', '45.90.30.0'],
      source: 'https://github.com/curl/curl/wiki/DNS-over-HTTPS'
    },
    {
      name: 'OpenDNS',
      servers: ['208.67.222.222', '208.67.220.220'],
      source: 'https://github.com/curl/curl/wiki/DNS-over-HTTPS'
    },
    {
      name: 'OpenNIC',
      servers: ['134.195.4.2', '144.24.127.228'],
      source: 'https://raw.githubusercontent.com/DNSCrypt/dnscrypt-resolvers/master/v3/public-resolvers.md'
    },
    {
      name: 'Quad9',
      servers: ['9.9.9.9', '149.112.112.112'],
      source: 'https://github.com/curl/curl/wiki/DNS-over-HTTPS'
    }
  ]

  class << self
    def list(resolver_name = nil)
      if resolver_name
        resolver = find_resolver(resolver_name)
        display_resolver(resolver)
      else
        RESOLVERS.each do |resolver|
          display_resolver(resolver)
        end
      end
    end

    def switch(resolver_name = nil)
      old_dns = current_dns
      candidate_resolver = resolver_name ? find_resolver(resolver_name) : random_resolver
      verify_proposed_change(candidate_resolver)
      candidate_dns = candidate_resolver[:servers]
      if vpn_up?
        switch_with_vpn(candidate_dns)
      else
        switch_without_vpn(candidate_dns)
      end
      verify_dns_change(old_dns, candidate_dns)
      candidate_resolver
    end

    def status
      current_servers = current_dns
      current_resolver = RESOLVERS.find{|r| r[:servers] == current_servers}

      puts "Interface: #{primary_hardware_port}"
      puts "Current DNS: #{current_servers.join(', ')}"
      puts "Resolver: #{current_resolver ? current_resolver[:name] : 'Unknown/Custom'}"
    end

    private

    def find_resolver(name)
      resolver = RESOLVERS.find{|r| r[:name].downcase == name.downcase}
      raise "Unknown resolver: #{name}" unless resolver
      resolver
    end

    def display_resolver(resolver)
      puts "Name: #{resolver[:name]}"
      puts "DNS Servers: #{resolver[:servers].join(', ')}"
      puts "Source: #{resolver[:source]}"
    end

    def switch_with_vpn(candidate_dns)
      unless mercurial_available?
        raise "VPN detected but mercurial not found in PATH."
      end
      system("mercurial switch --dns_servers #{candidate_dns.join(',')} --retain_endpoint")
      unless $?.success?
        raise "Failed to restart VPN with new DNS servers."
      end
    end

    def switch_without_vpn(candidate_dns)
      set_dns(candidate_dns)
    end

    def random_resolver
      current_resolver = RESOLVERS.find{|r| r[:servers] == current_dns}
      non_current_resolvers = current_resolver ? (RESOLVERS - [current_resolver]) : RESOLVERS
      non_current_resolvers.sample
    end

    def primary_hardware_port
      active_interface = MacOS::IfConfig.active_interfaces.first
      raise "No active network interfaces found" unless active_interface

      hardware_port = MacOS::HardwarePort.find_by_interface(active_interface.interface)
      raise("Hardware port not found for #{active_interface.interface}") unless hardware_port

      hardware_port.name
    end

    def current_dns(hardware_port = primary_hardware_port)
      output = `networksetup -getdnsservers "#{hardware_port}"`.strip
      return [] if output.include?("There aren't any DNS Servers set")
      output.split("\n")
    end

    def set_dns(dns_servers, hardware_port = primary_hardware_port)
      system("sudo networksetup -setdnsservers #{hardware_port} #{dns_servers.join(' ')}")
      raise "networksetup command failed" unless $?.success?
    end

    def verify_proposed_change(candidate_resolver)
      candidate_dns = candidate_resolver[:servers]
      if candidate_dns == current_dns
        raise "Already using #{candidate_resolver[:name]}"
      end
    end

    def verify_dns_change(old_dns, candidate_dns)
      if vpn_up?
        sleep(3) # It takes longer for the VPN to be dropped and brought back up again.
      else
        sleep(1)
      end
      new_dns = current_dns
      unless old_dns != new_dns && new_dns == candidate_dns
        raise "DNS switch verification failed. Started with #{old_dns.join(',')}, expected #{candidate_dns.join(',')}, but got #{new_dns.join(',')}."
      end
    end

    # predicate methods

    def mercurial_available?
      FileUtils.which('mercurial')
    end

    def vpn_up?
      MacOS::VPN.up?
    end
  end
end

def main
  case ARGV[0]
  when 'list'
    Revolver.list(ARGV[1])
  when 'switch'
    Revolver.switch(ARGV[1])
  when 'status'
    Revolver.status
  else
    puts "Usage: revolver [list [resolver_name] | switch [resolver_name] | status]"
  end
rescue => e
  puts "Error: #{e.message}"
  exit 1
end

main if $0 == __FILE__
